

/* Точка входа в программу */
ENTRY(Reset_Handler)
_estack = 0x20001000;    /* end of RAM */
/* Определяем перемнную которая содержит значение размера кучи */
_Min_Heap_Size = 0x100;  
/* Определяем перемнную которая содержит значение размера стека*/   
_Min_Stack_Size = 0x400; 

/* Регионы памяти для stm32f030C6*/
/* ORIGIN - начало  LENGTH - Размер*/
MEMORY
{
RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 4K  /* w - запись */
FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 32K /* r-читать x-выполнять */
}

/* Описываем выходные секции */

/* SECTIONS {
...
secname start BLOCK(align) (NOLOAD) : AT ( ldadr )
  { contents } >region :phdr =fill
...

secname : имя выходного раздела.
start : Укажите адрес, по которому будет загружен выходной раздел.
БЛОК(выравнивание) : Увеличивает значение счетчика местоположений. до начала раздела, поэтому раздел начнется с указанного выравнивания.
(BLOCK) : Отметьте раздел, который не будет загружаться во время выполнения.
AT ( ldadr ) : Укажите адрес загрузки раздела в «ldadr». Если не использовать ключевое слово AT , адрес загрузки раздела по умолчанию совпадает с адресом перемещения.
>region : Назначьте этот раздел определенной области памяти.
'secname' и 'contents' необходимы для определения раздела, остальные являются необязательными.

} */

/* 1 - я секция */
SECTIONS
{
  .isr_vector : /* Таблица векторов прерывания */
  {
    . = ALIGN(4); /* Выравниваем текущую позицию на границу 4-х байт. */
    KEEP(*(.isr_vector)) /* Запись (*(.isr_vector)) означает разделы .isr_vector во всех объектных файлах *KEEP() - сборщик не должен трогать эту секцию*/
    . = ALIGN(4);
  } >FLASH /* поместить во flash*/

/* Секция .isr_vector, которая содержит таблицу векторов прерываний выравнивается 
 по границе 4-х байт, помечается как недоступная для сборщика мусора и размещается в начале 
 FLASH памяти микроконтроллера. */

/* Линковщик идёт сверу вниз*/

  /* Код программы */
  .text :
  {
    . = ALIGN(4);
    *(.text)           /* Указываем, что в данной секции будут хранится области .text всех  объектных файлов */
    *(.text*)          /* можно писать конкретно main.o(.text) */
    *(.glue_7)         /* Этот раздел кода компоновщика просто говорит о том, чтобы поместить туда связующий код */
    *(.glue_7t)        /* */
    *(.eh_frame)

    KEEP (*(.init))    /* Защищаем от сборщика мусора секции .init и .fini */
    KEEP (*(.fini))

    . = ALIGN(4);
    _etext = .;        
    /* Определяется переменная _etext, которая хранит в себе адрес конца секции .text и которая
       может быть доступна в исходном тексте программы через объявление 
       volaile unsigned int extern _etext; */
  } >FLASH
  /*  Секция .text, которая содержит код программы выравнивается по границе 4-х байт, 
      включает в себя: все секции с кодом программы во всех объектных файлах и защищенные
      от сборщика муссора секции .init и .fini во всех объектных файлах, распологается во FLASH 
      памяти микроконтроллера сразу за таблицей векторов. 
      Секции text, .init и .fini. располагаются в памяти в той последовательности в которой они 
      объявлены в скрипте.*/

  /* Третья секция содержит константные данные. */
  .rodata :
  {
    . = ALIGN(4);
    *(.rodata)         /* Указываем, что в данной секции будут хранится области .rodataвсех объектных файлов */
    *(.rodata*)        /*  */
    . = ALIGN(4);
  } >FLASH


/*arm c++ virtual constructor e t.c.
 раскручиванием таблицы/цикла
 конструкторы, деструкторы
 Используя чистый С, можно удалить
 Но пока оставим, вдруг создадим совй класс со своими методами, конструкторами блекджеком и ..  для gpio?
 */
  .ARM.extab   : { *(.ARM.extab* .gnu.linkonce.armextab.*) } >FLASH
  .ARM : {
    __exidx_start = .;
    *(.ARM.exidx*)
    __exidx_end = .;
  } >FLASH

  .preinit_array     :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array*))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  } >FLASH
  .init_array :
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array*))
    PROVIDE_HIDDEN (__init_array_end = .);
  } >FLASH
  .fini_array :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT(.fini_array.*)))
    KEEP (*(.fini_array*))
    PROVIDE_HIDDEN (__fini_array_end = .);
  } >FLASH

  /* */
  _sidata = LOADADDR(.data);

  /* Четвертая секция содержит инициализированные переменные */
  .data : 
  {
    . = ALIGN(4);
    _sdata = .;        /* Сохраняем в переменной _sdata адрес текущей позиции (начала секции) */
    *(.data)           /* Указываем, что в данной секции будут хранится области .data всех объектных файлов */
    *(.data*)          /* */

    . = ALIGN(4);
    _edata = .;        /* Сохраняем в переменной _sdata адрес текущей позиции (конец секции)*/
  } >RAM AT>FLASH

  /* Функция AT указывает на то, что данный сектор хранится в одной области памяти 
     (в нашем случае FLASH), а исполняться будет из другой обасти памяти (в нашем случае RAM). 
     Есть два типа адрессов:
     * VMA (Virtual memory address) - это run-time адрес по которому компилятор ожидает 
       видеть данные.
     * LMA (Load memory address) - это адрес по которому линкер хранит данные.         
     Startup должен код скопировать секцию .data из адрессов LMA в адресса VMA.*/

  
  /* Пятая секция содержит инициализированные нулем переменные и все переменные без инициализации
   т.к. *(COMMON). */
  . = ALIGN(4);
  .bss :
  {
    /*  Сохраняем в переменной _sbss и __bss_start__  адрес текущей позиции (начала секции)*/
    _sbss = .;         /*  */
    __bss_start__ = _sbss;
    /* Указываем, что в данной секции будут хранится области .bss всех объектных файлов */
    *(.bss)
    *(.bss*)
    *(COMMON)

    . = ALIGN(4);
    _ebss = .;         /* Сохраняем в переменной _ebss и __bss_end__ адрес текущей позиции (начала секции) */
    __bss_end__ = _ebss;
  } >RAM

  /* Шестая секция содержит кучу и стек. Размещается в самом конце RAM*/
  ._user_heap_stack :
  {
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
  } >RAM

  

  /* Remove information from the standard libraries */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }

  .ARM.attributes 0 : { *(.ARM.attributes) }
  
}


